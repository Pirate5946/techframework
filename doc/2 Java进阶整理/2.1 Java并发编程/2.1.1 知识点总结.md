- [并发知识点 - 在线整理](http://concurrent.redspider.group/article/01/2.html)
- [参考博客 - 0](https://blog.csdn.net/cai13070139328/article/details/98874110)
- [参考博客 - 并发编程知识点](http://concurrent.redspider.group/article/01/1.html)
- [Synchronized关键字深析（小白慎入，深入jvm源码，两万字长文）
](https://blog.csdn.net/weixin_42762133/article/details/103241439?depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendHotData-14&utm_source=distribute.pc_relevant.none-task-blog-BlogCommendHotData-14)
---

### 可见性

### 有序性 ：   
线程的启动先后顺序 与执行先后顺序无关，Jvm和操作系统一起决定了线程的执行顺序

如何控制线程的执行顺序？

### 原子性

---

### 1.0 Java并发编程基本知识介绍
http://www.tianshouzhi.com/api/tutorials/mutithread


http://www.tianshouzhi.com/api/tutorials/mutithread/67

竞态条件：当两个线程竞争同一资源时，如果对资源的访问顺序敏感，就称存在竞态条件

对象锁：同步在一个对象上的同步块，在同一时刻只能被一个线程进入 并执行操作,    其他等待进入该同步块的线程将被阻塞，直到执行该同步块中的线程退出。

#### [四种不同的同步块](https://mp.weixin.qq.com/s?__biz=MzI5MzYzMDAwNw==&mid=2247487657&idx=2&sn=92bf444364a56eda2b64fc3bb3e2a4a7&chksm=ec6e69f1db19e0e7f33c912ac1173769a228a9efec276f772f4fa85e59bbe9421f27e854954b&mpshare=1&scene=1&srcid=&sharer_sharetime=1575244298056&sharer_shareid=40ab0d7d5cfdb4218441d9441c4831a6#rd) 
1. 实例方法     
对于普通同步方法（实例方法），锁是当前实例对象
  
    synchronized 修饰的方法并没有 monitorenter 指令和 monitorexit 指令，取得代之的确实是 ACC_SYNCHRONIZED 标识，该标识指明了该方法是一个同步方法
    同步在拥有该方法的对象上，   
    注意：多个线程要运行的是同一个对象实例的同步方法，   
    如果一个每个线程运行的是不同的对象实例的同步方法，是没有同步效果的，  
    因为每个对象实例是把自身当成锁，就导致没有公用一个锁。
    
2. 实例方法中的同步块    
对于同步方法块，锁是synchronized 括号里的配置的对象
      
    synchronized 同步语句块的实现使用的是 monitorenter 和 monitorexit 指令
    在同步构造器中用括号括起来的对象叫做监视器对象,监视器对象可以是任意一个对象的class实例      
    如果两个同步块不是同步在同一个class对象上。那么这两个同步块可以同时被线程访问
    
3. 静态方法         
对于静态同步方法，锁是当前类的Class对象

    使用的是类锁，同一个类的不同对象 用的也是同一个锁    
    
注意：当一个线程正在访问一个对象的 synchronized 实例方法，那么其他线程不能访问该对象的其他 synchronized 方法，   毕竟一个对象只有一把锁，    
当一个线程获取了该对象的锁之后，其他线程无法获取该对象的锁，所以无法访问该对象的其他synchronized实例方法，     
但是其他线程还是可以访问该实例对象的其他非synchronized方法。
   
==总之，Java的每一个对象都可以作为锁，只要访问的是同一个对象，那就受限于此对象的锁，不同的对象则不会相互干扰==

#### synchronized底层实现原理
Java 虚拟机中的同步(Synchronization)基于进入和退出 Monitor对象 来实现方法同步和代码块同步,Monitor对象存放在Java对象头中

Java对象在HotSpot虚拟机中的内存布局可分为3块区域：对象头(Header)、实例数据(Instance Data)和对齐填充(Padding)。

synchronized用的锁是存储在Java对象头里的，JVM采用2个字来存储对象头(如果对象是数组则会分配3个字，多出来的1个字记录的是数组长度)，    
其主要结构是由Mark Word 和 Class Metadata Address 两个部分组成

在Java虚拟机(HotSpot)中，monitor是由ObjectMonitor实现的

注意： 
1. synchronized同步块对于同一线程来说是可重入的，即不会自己锁死自己
2. 同步块在已进入的线程执行完之前，会阻塞后面其他线程的进入

效率问题：       
因为Java的线程是映射在操作系统原生线程之上的，阻塞或唤醒一个线程，都需要操作系统帮忙完成，     
这就需要从用户态转换到核心态中，而这个状态之间的转换需要相对比较长的处理器时间，        
对此HotSpot虚拟机开发团队对synchronized锁进行了大量的优化措施。


#### CAS
在使用synchronized时，线程获取锁是一种悲观锁策略，即假设每一次执行临界区代码都会产生冲突，所以当前线程获取到锁的时候同时也会阻塞其他线程获取该锁。

而CAS（compare and swap）又叫做比较交换操作是一种乐观锁策略         
先进行比较操作，如果没有其他线程竞争共享数据就操作成功了；如果共享数据有争用，出现冲突了就重试当前操作直到没有冲突为止
##### CAS带来的ABA问题
atomic包中提供了AtomicStampedReference来解决ABA问题相当于添加了版本号

#### 锁的优化
锁的状态从低到高一共有四种：无锁状态、偏向锁、轻量级锁和重量级锁。这几个状态会随着竞争情况逐渐升级，但锁不可降级，意味着锁从偏向锁升级到轻量级锁后不能再回到偏向锁级，这是为了提高获得和释放锁的效率。

##### 1.偏向锁
偏向锁在JVM是默认启动的,竞争激烈的情况下应该通过JVM参数关闭：UserBiasedLocking = false,那么程序默认进入轻量级锁状态。