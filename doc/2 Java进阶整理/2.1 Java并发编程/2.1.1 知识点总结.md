
---

### 可见性

### 有序性 ：   
线程的启动先后顺序 与执行先后顺序无关，Jvm和操作系统一起决定了线程的执行顺序

如何控制线程的执行顺序？

### 原子性

---

### 1.0 Java并发编程基本知识介绍
http://www.tianshouzhi.com/api/tutorials/mutithread


http://www.tianshouzhi.com/api/tutorials/mutithread/67

竞态条件：当两个线程竞争同一资源时，如果对资源的访问顺序敏感，就称存在竞态条件

对象锁：同步在一个对象上的同步块，在同一时刻只能被一个线程进入 并执行操作,    其他等待进入该同步块的线程将被阻塞，直到执行该同步块中的线程退出。

#### 四种不同的同步块 https://mp.weixin.qq.com/s?__biz=MzI5MzYzMDAwNw==&mid=2247487657&idx=2&sn=92bf444364a56eda2b64fc3bb3e2a4a7&chksm=ec6e69f1db19e0e7f33c912ac1173769a228a9efec276f772f4fa85e59bbe9421f27e854954b&mpshare=1&scene=1&srcid=&sharer_sharetime=1575244298056&sharer_shareid=40ab0d7d5cfdb4218441d9441c4831a6#rd
1. 实例方法     
    synchronized 修饰的方法并没有 monitorenter 指令和 monitorexit 指令，取得代之的确实是 ACC_SYNCHRONIZED 标识，该标识指明了该方法是一个同步方法
    同步在拥有该方法的对象上，   
    注意：多个线程要运行的是同一个对象实例的同步方法，   
    如果一个每个线程运行的是不同的对象实例的同步方法，是没有同步效果的，  
    因为每个对象实例是把自身当成锁，就导致没有公用一个锁。
    
2. 实例方法中的同步块        
    synchronized 同步语句块的实现使用的是 monitorenter 和 monitorexit 指令
    在同步构造器中用括号括起来的对象叫做监视器对象,监视器对象可以是任意一个对象的class实例      
    如果两个同步块不是同步在同一个class对象上。那么这两个同步块可以同时被线程访问
    
3. 静态方法     
    使用的是类锁，同一个类的不同对象 用的也是同一个锁    