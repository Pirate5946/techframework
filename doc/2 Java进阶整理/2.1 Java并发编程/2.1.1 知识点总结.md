- [并发知识点 - 在线整理](http://concurrent.redspider.group/article/01/2.html)
- [参考博客 - 0](https://blog.csdn.net/cai13070139328/article/details/98874110)
- [参考博客 - 并发编程知识点](http://concurrent.redspider.group/article/01/1.html)
- [Synchronized关键字深析（小白慎入，深入jvm源码，两万字长文）
](https://blog.csdn.net/weixin_42762133/article/details/103241439?depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendHotData-14&utm_source=distribute.pc_relevant.none-task-blog-BlogCommendHotData-14)
---

### 可见性

### 有序性 ：   
线程的启动先后顺序 与执行先后顺序无关，Jvm和操作系统一起决定了线程的执行顺序

如何控制线程的执行顺序？

### 原子性

---

### 1.0 Java并发编程基本知识介绍
http://www.tianshouzhi.com/api/tutorials/mutithread


http://www.tianshouzhi.com/api/tutorials/mutithread/67

竞态条件：当两个线程竞争同一资源时，如果对资源的访问顺序敏感，就称存在竞态条件

对象锁：同步在一个对象上的同步块，在同一时刻只能被一个线程进入 并执行操作,    其他等待进入该同步块的线程将被阻塞，直到执行该同步块中的线程退出。

#### [四种不同的同步块](https://mp.weixin.qq.com/s?__biz=MzI5MzYzMDAwNw==&mid=2247487657&idx=2&sn=92bf444364a56eda2b64fc3bb3e2a4a7&chksm=ec6e69f1db19e0e7f33c912ac1173769a228a9efec276f772f4fa85e59bbe9421f27e854954b&mpshare=1&scene=1&srcid=&sharer_sharetime=1575244298056&sharer_shareid=40ab0d7d5cfdb4218441d9441c4831a6#rd) 
1. 实例方法     
对于普通同步方法（实例方法），锁是当前实例对象
  
    synchronized 修饰的方法并没有 monitorenter 指令和 monitorexit 指令，取得代之的确实是 ACC_SYNCHRONIZED 标识，该标识指明了该方法是一个同步方法
    同步在拥有该方法的对象上，   
    注意：多个线程要运行的是同一个对象实例的同步方法，   
    如果一个每个线程运行的是不同的对象实例的同步方法，是没有同步效果的，  
    因为每个对象实例是把自身当成锁，就导致没有公用一个锁。
    
2. 实例方法中的同步块    
对于同步方法块，锁是synchronized 括号里的配置的对象
      
    synchronized 同步语句块的实现使用的是 monitorenter 和 monitorexit 指令
    在同步构造器中用括号括起来的对象叫做监视器对象,监视器对象可以是任意一个对象的class实例      
    如果两个同步块不是同步在同一个class对象上。那么这两个同步块可以同时被线程访问
    
3. 静态方法         
对于静态同步方法，锁是当前类的Class对象

    使用的是类锁，同一个类的不同对象 用的也是同一个锁    
    
注意：当一个线程正在访问一个对象的 synchronized 实例方法，那么其他线程不能访问该对象的其他 synchronized 方法，   毕竟一个对象只有一把锁，    
当一个线程获取了该对象的锁之后，其他线程无法获取该对象的锁，所以无法访问该对象的其他synchronized实例方法，     
但是其他线程还是可以访问该实例对象的其他非synchronized方法。
   
==总之，Java的每一个对象都可以作为锁，只要访问的是同一个对象，那就受限于此对象的锁，不同的对象则不会相互干扰==

#### synchronized底层实现原理
Java 虚拟机中的同步(Synchronization)基于进入和退出 Monitor对象 来实现方法同步和代码块同步,Monitor对象存放在Java对象头中

Java对象在HotSpot虚拟机中的内存布局可分为3块区域：对象头(Header)、实例数据(Instance Data)和对齐填充(Padding)。

synchronized用的锁是存储在Java对象头里的，JVM采用2个字来存储对象头(如果对象是数组则会分配3个字，多出来的1个字记录的是数组长度)，    
其主要结构是由Mark Word 和 Class Metadata Address 两个部分组成

在Java虚拟机(HotSpot)中，monitor是由ObjectMonitor实现的

注意： 
1. synchronized同步块对于同一线程来说是可重入的，即不会自己锁死自己
2. 同步块在已进入的线程执行完之前，会阻塞后面其他线程的进入

效率问题：       
因为Java的线程是映射在操作系统原生线程之上的，阻塞或唤醒一个线程，都需要操作系统帮忙完成，     
这就需要从用户态转换到核心态中，而这个状态之间的转换需要相对比较长的处理器时间，        
对此HotSpot虚拟机开发团队对synchronized锁进行了大量的优化措施。


#### CAS
在使用synchronized时，线程获取锁是一种悲观锁策略，即假设每一次执行临界区代码都会产生冲突，所以当前线程获取到锁的时候同时也会阻塞其他线程获取该锁。

而CAS（compare and swap）又叫做比较交换操作是一种乐观锁策略         
先进行比较操作，如果没有其他线程竞争共享数据就操作成功了；如果共享数据有争用，出现冲突了就重试当前操作直到没有冲突为止
##### CAS带来的ABA问题
atomic包中提供了AtomicStampedReference来解决ABA问题相当于添加了版本号

#### 锁的优化
锁的状态从低到高一共有四种：无锁状态、偏向锁、轻量级锁和重量级锁。这几个状态会随着竞争情况逐渐升级，但锁不可降级，意味着锁从偏向锁升级到轻量级锁后不能再回到偏向锁级，这是为了提高获得和释放锁的效率。

##### 1.偏向锁
偏向锁在JVM是默认启动的,竞争激烈的情况下应该通过JVM参数关闭：UserBiasedLocking = false,那么程序默认进入轻量级锁状态。

#### 线程状态 、主要方法
http://concurrent.redspider.group/article/01/4.html

![image](http://concurrent.redspider.group/article/01/imgs/%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2%E5%9B%BE.png)

### Java线程间的通信
http://concurrent.redspider.group/article/01/5.html

#### 5.1 锁与同步

#### 5.2 等待/通知机制

#### 5.3 信号量

多个线程（超过2个）需要相互合作，我们用简单的“锁”和“等待通知机制”就不那么方便了。这个时候就可以用到信号量

#### 5.4 管道

#### 5.5 其它通信相关
以上介绍了一些线程间通信的基本原理和方法。除此以外，还有一些与线程通信相关的知识点，这里一并介绍。

##### 5.5.1 join方法
join()方法是Thread类的一个实例方法。它的作用是让当前线程陷入“等待”状态，等join的这个线程执行完成后，再继续执行当前线程

##### 5.5.2 sleep方法
sleep方法是不会释放当前的锁的，而wait方法会。这也是最常见的一个多线程面试题。
- wait可以指定时间，也可以不指定；而sleep必须指定时间。
- wait释放cpu资源，同时释放锁；sleep释放cpu资源，但是不释放锁，所以易死锁。
- wait必须放在同步块或同步方法中，而sleep可以再任意位置

##### 5.5.3 ThreadLocal类
ThreadLocal是一个本地线程副本变量工具类。内部是一个弱引用的Map来维护

ThreadLocal类并不属于多线程间的通信，而是让每个线程有自己”独立“的变量，线程之间互不影响。它为每个线程都创建一个副本，每个线程可以访问自己内部的副本变量。

最常见的ThreadLocal使用场景为用来解决数据库连接、Session管理等。数据库连接和Session管理涉及多个复杂对象的初始化和关闭

##### 5.5.4 InheritableThreadLocal
  InheritableThreadLocal类与ThreadLocal类稍有不同，Inheritable是继承的意思。它不仅仅是当前线程可以存取副本值，而且它的子线程也可以存取这个副本值 
  
## Java内存模型基础知识  
### 既然堆是共享的，为什么在堆中会有内存不可见问题？   
根据JMM的规定，线程对共享变量的所有操作都必须在自己的本地内存中进行，不能直接从主内存中读取。  

JMM通过控制主内存与每个线程的本地内存之间的交互，来提供内存可见性保证

    Java中的volatile关键字可以保证多线程操作共享变量的可见性以及禁止指令重排序，synchronized关键字不仅保证可见性，同时也保证了原子性（互斥性）
    
    在更底层，JMM通过内存屏障来实现内存的可见性以及禁止重排序

### 7.1 什么是重排序？
计算机在执行程序时，为了提高性能，编译器和处理器常常会对指令做重排。

    
指令重排可以保证串行语义一致，但是没有义务保证多线程间的语义也一致。所以在多线程下，指令重排序可能会导致一些问题。

### 7.2 顺序一致性模型与JMM的保证
使用volatile、final、synchronized等关键字来实现多线程下的同步    

JMM的具体实现方针是：在不改变（正确同步的）程序执行结果的前提下，尽量为编译期和处理器的优化打开方便之门。

### 7.3 happens-before
happens-before关系的定义如下：

1. 如果一个操作happens-before另一个操作，那么第一个操作的执行结果将对第二个操作可见，而且第一个操作的执行顺序排在第二个操作之前。

2. 两个操作之间存在happens-before关系，并不意味着Java平台的具体实现必须要按照happens-before关系指定的顺序来执行。如果重排序之后的执行结果，与按happens-before关系来执行的结果一致，那么JMM也允许这样的重排序。

在Java中，有以下天然的happens-before关系：

- 程序顺序规则：一个线程中的每一个操作，happens-before于该线程中的任意后续操作。
- 监视器锁规则：对一个锁的解锁，happens-before于随后对这个锁的加锁。
- volatile变量规则：对一个volatile域的写，happens-before于任意后续对这个volatile域的读。
- 传递性：如果A happens-before B，且B happens-before C，那么A happens-before C。
- start规则：如果线程A执行操作ThreadB.start()启动线程B，那么A线程的ThreadB.start（）操作happens-before于线程B中的任意操作、
- join规则：如果线程A执行操作ThreadB.join（）并成功返回，那么线程B中的任意操作happens-before于线程A从ThreadB.join()操作成功返回


重排序有两类，JMM对这两类重排序有不同的策略：

1. 会改变程序执行结果的重排序，比如 A -> C，JMM要求编译器和处理器都禁止这种重排序。
2. 不会改变程序执行结果的重排序，比如 A -> B，JMM对编译器和处理器不做要求，允许这种重排序

## 8. volatile
从volatile的内存语义上来看，volatile可以保证内存可见性且禁止重排序。

volatile仅仅保证对单个volatile变量的读/写具有原子性，而锁可以保证整个临界区代码的执行具有原子性。所以在功能上，锁比volatile更强大；在性能上，volatile更有优势

### 8.2.1 禁止重排序
JVM是怎么还能限制处理器的重排序的呢？它是通过内存屏障来实现的。

什么是内存屏障？硬件层面，内存屏障分两种：读屏障（Load Barrier）和写屏障（Store Barrier）。内存屏障有两个作用：

阻止屏障两侧的指令重排序；
强制把写缓冲区/高速缓存中的脏数据等写回主内存，或者让缓存中相应的数据失效。

## 9 synchronized与锁
Java多线程的锁都是基于对象的，Java中的每一个对象都可以作为一个锁。

还有一点需要注意的是，我们常听到的类锁其实也是对象锁。

Java类只有一个Class对象（可以有多个实例对象，多个实例共享这个Class对象），而Class对象也是特殊的Java对象。        
所以我们常说的类锁，其实就是Class对象的锁。

### 9.1 Synchronized关键字
所谓“临界区”，指的是某一块代码区域，它同一时刻只能由一个线程执行

### 9.2 几种锁
Java 6 为了减少获得锁和释放锁带来的性能消耗，引入了“偏向锁”和“轻量级锁“。在Java 6 以前，所有的锁都是”重量级“锁。所以在Java 6 及其以后，一个对象其实有四种锁状态，它们级别由低到高依次是：

- 无锁状态
- 偏向锁状态
- 轻量级锁状态
- 重量级锁状态


#### 9.2.2 偏向锁
偏向锁在资源无竞争情况下消除了同步语句，连CAS操作都不做了，提高了程序的运行性能。