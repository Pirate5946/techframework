系统运行过程中的一种“短时间内遇到大量操作请求”的情况，

比如web系统运行时收到大量请求，如12306抢票、双11等

该情况的发生会导致系统在该段时间内执行大量操作，例如对资源的请求、数据库的操作等。

- [高并发的理解和使用场景-----特意区别和多线程的关系](https://www.cnblogs.com/feichen-66/p/11207847.html)

1. 高并发的定义
  就是短时间内遇到大量操作请求，导致站点服务器/db服务器资源被占满 甚至严重时直接导致宕机

2. 高并发的原因
一般应用的并发瓶颈体现在数据库的QPS ，内存配置 

3.高并发的场景
  一般像火车票抢票，秒杀 系统，双11或者京东618活动等这种太明显不过了，这种还是正常的业务范围，蛮好理解的，
  还有一种就是恶意的攻击，导致系统的某个功能近乎瘫痪，比如验证码的请求等

4. 如何应对高并发
 要想系统能够适应高并发状态，则需要从各个方面进行系统优化，包括，硬件、网络、系统架构、开发语言的选取、数据结构的运用、算法优化、数据库优化等…
 而多线程只是其中解决方法之一。
 
 并发读还好，一般使用缓存就可以搞定
 
 并发写技术就比较多了；

     一般我们都知道 并发时最怕的就是对共享变量的同时访问导致脏数据的产生，所以一般会加锁：对象锁（例如：syncrinized等关键字）和 分布式锁（数据库锁，redis，zookeeper）

    对象锁顾名思义就是锁住当前对象--只能用在单服务器上，对于分布式系统或者单系统分布式部署时对共享资源的访问就必须使用分布式锁了，此时对象锁没法用了 

    像秒杀系统可以使用缓存让还有数量时都可以看到，而在开抢后得看个人运气了（网络等原因），此时使用乐观锁（共享锁）就搞定了嘛

    像银行的消费后更新银行卡余额，使用悲观锁（排斥锁）就可以

 a.分布式缓存：redis、memcached等，

 b.系统采用水平方向扩展，尽量使用集群来分散处理多请求。

 c.应用拆分:一个工程被拆分为多个工程部署，利用dubbo解决多工程之间的通信。

 d.数据库分库分表等。

 e .数据库读写分离，解决大数据的查询问题。

 f.还可以利用nosql ，例如mongoDB配合mysql组合使用。

g.还需要建立大数据访问情况下的服务降级以及限流机制等。

h.消息队列中间件：activeMQ等，解决大量消息的异步处理能力。

---
https://www.jianshu.com/p/99d93e618377

案例一:
订票系统案例，某航班只有一张机票，假定有1w个人打开你的网站来订票，问你如何解决并发问题(可扩展到任何高并发网站要考虑的并发读写问题)



问题，1w个人来访问，票没出去前要保证大家都能看到有票，不可能一个人在看到票的时候别人就不能看了。到底谁能抢到，那得看这个人的“运气”（网络快慢等）

其次考虑的问题，并发，1w个人同时点击购买，到底谁能成交？总共只有一张票