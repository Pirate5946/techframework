- [ConcurrentHashMap源码分析，轻取面试Offer（一）](https://blog.csdn.net/qq_35425070/article/details/84672765)

### ConcurrentHashMap 初始化是怎么做到线程安全的？
就算有多个线程同时进行put操作，在初始化数组时使用了乐观锁CAS操作来决定到底是哪个线程有资格进行初始化，其他线程均只能等待。

用到的并发技巧：
- volatile变量（sizeCtl）：它是一个标记位，用来告诉其他线程这个坑位有没有人在，其线程间的可见性由volatile保证。
- CAS操作：CAS操作保证了设置sizeCtl标记位的原子性，保证了只有一个线程能设置成功

#### get方法如何线程安全地获取key、value？

#### put方法如何线程安全地设置key、value？
##### 减小锁粒度：
将Node链表的头节点作为锁，若在默认大小16情况下，将有16把锁，大大减小了锁竞争（上下文切换），      
就像开头所说，将串行的部分最大化缩小,在理想情况下线程的put操作都为并行操作。           
同时直接锁住头节点，保证了线程安全

##### Unsafe的getObjectVolatile方法：
此方法确保获取到的值为最新



#### size方法如果线程安全地获取容器容量？

#### 底层数据结构扩容时如果保证线程安全？

#### 初始化数据结构时如果保证线程安全？


### ConcurrentHashMap并发效率是如何提高的？
ConcurrentHashMap则使用了锁分段（减小锁范围）、CAS（乐观锁，减小上下文切换开销，无阻塞）等等技术

#### 和加锁相比较，为什么它比HashTable效率高？



我们在多线程中使用线程安全类时也需要注意是否用到了2个及以上的同步方法，        
若用到了则需要将这多个方法使用同步变成原子操作
```java

```