## 第2章　Java内存区域与内存溢出异常
Java与C++之间有一堵由内存动态分配和垃圾收集技术所围成的“高墙”，墙外面的人想
进去，墙里面的人却想出来。      
对于Java程序员来说，在虚拟机自动内存管理机制的帮助下，不再需要为每一个new操
作去写配对的delete/free代码，不容易出现内存泄漏和内存溢出问题，由虚拟机管理内存这
一切看起来都很美好。    
不过，也正是因为Java程序员把内存控制的权力交给了Java虚拟机，
一旦出现内存泄漏和溢出方面的问题，如果不了解虚拟机是怎样使用内存的，那么排查错误
将会成为一项异常艰难的工作。
> 本章介绍Java虚拟机内存的各个区域，讲解这些
区域的作用、服务对象以及其中可能产生的问题
### 2.2　运行时数据区域
Java虚拟机在执行Java程序的过程中会把它所管理的内存划分为若干个不同的数据区
域。    
这些区域都有各自的用途，以及创建和销毁的时间，有的区域随着虚拟机进程的启动而
存在，有些区域则依赖用户线程的启动和结束而建立和销毁

- 方法区
- 堆
- 虚拟机栈
- 本地方法栈
- 程序计数器
#### 2.2.1　程序计数器  p60
程序计数器（Program Counter Register）是一块较小的内存空间，它可以看作是当前线程所执行的字节码的行号指示器。    
在虚拟机的概念模型里（仅是概念模型，各种虚拟机可能
会通过一些更高效的方式去实现），    
字节码解释器工作时就是通过改变这个计数器的值来选
取下一条需要执行的字节码指令，==分支、循环、跳转、异常处理、线程恢复==等基础功能都需
要依赖这个计数器来完成。 

由于Java虚拟机的多线程是通过线程轮流切换并分配处理器执行时间的方式来实现的，
在任何一个确定的时刻，一个处理器（对于多核处理器来说是一个内核）都只会执行一条线
程中的指令。因此，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立
的程序计数器，各条线程之间计数器互不影响，独立存储，我们称这类内存区域为“线程私
有”的内存。

如果线程正在执行的是一个Java方法，这个计数器记录的是正在执行的虚拟机字节码指
令的地址；如果正在执行的是Native方法，这个计数器值则为空（Undefined）。此内存区域
是唯一一个在Java虚拟机规范中没有规定任何OutOfMemoryError情况的区域。
#### 2.2.2　Java虚拟机栈
与程序计数器一样，Java虚拟机栈（Java Virtual Machine Stacks）也是线程私有的

虚拟机栈描述的是Java方法执行的内存模型：每个方法在执行的同时
都会创建一个栈帧（Stack Frame[1]）用于存储==局部变量表==、==操作数栈==、==动态链接==、方法出口
等信息。每一个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出
栈的过程。 

局部变量表存放了编译期可知的各种基本数据类型、对象引用和
returnAddress类型（指向了一条字节码指令的地址）。

其中64位长度的long和double类型的数据会占用2个局部变量空间（Slot），其余的数据
类型只占用1个。==局部变量表所需的内存空间在编译期间完成分配==，当进入一个方法时，这
个方法需要在帧中分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变
量表的大小。

在Java虚拟机规范中，对这个区域规定了两种异常状况：如果线程请求的栈深度大于虚
拟机所允许的深度，将抛出==StackOverflowError==异常；如果虚拟机栈可以动态扩展（当前大部
分的Java虚拟机都可动态扩展，只不过Java虚拟机规范中也允许固定长度的虚拟机栈），如
果扩展时无法申请到足够的内存，就会抛出==OutOfMemoryError==异常。
#### 2.2.3　本地方法栈 Native Method Stack
本地方法栈（Native Method Stack）与虚拟机栈所发挥的作用是非常相似的，它们之间
的区别不过是虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则为虚
拟机使用到的Native方法服务。    

在虚拟机规范中对本地方法栈中方法使用的语言、使用方式
与数据结构并没有强制规定，因此具体的虚拟机可以自由实现它。  

甚至有的虚拟机（譬如
Sun HotSpot虚拟机）直接就把本地方法栈和虚拟机栈合二为一。与虚拟机栈一样，        

本地方法
栈区域也会抛出StackOverflowError和OutOfMemoryError异常。
#### 2.2.4　Java堆
对于大多数应用来说，Java堆（Java Heap）是Java虚拟机所管理的内存中最大的一块。
Java堆是被所有线程共享的一块内存区域，==在虚拟机启动时创建==。

此内存区域的唯一目的就
是存放对象实例，几乎所有的对象实例都在这里分配内存。

Java堆是垃圾收集器管理的主要区域

从内存回收的角度来看，由于现在收集器基
本都采用分代收集算法，所以Java堆中还可以细分为：新生代和老年代；再细致一点的有
Eden空间、From Survivor空间、To Survivor空间等

根据Java虚拟机规范的规定，Java堆可以处于物理上不连续的内存空间中，只要逻辑上
是连续的即可，就像我们的磁盘空间一样。在实现时，既可以实现成固定大小的，也可以是
可扩展的，不过当前主流的虚拟机都是按照可扩展来实现的（通过-Xmx和-Xms控制）。如
果在堆中没有内存完成实例分配，并且堆也无法再扩展时，将会抛出==OutOfMemoryError==异常。
#### 2.2.5　方法区
方法区（Method Area）与Java堆一样，是各个线程共享的内存区域，它用于存储已被虚
拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据

Java虚拟机规范对方法区的限制非常宽松，除了和Java堆一样不需要连续的内存和可以
选择固定大小或者可扩展外，还可以选择不实现垃圾收集。相对而言，垃圾收集行为在这个区域是比较少出现的

根据Java虚拟机规范的规定，当方法区无法满足内存分配需求时，将抛出OutOfMemoryError异常。
#### 2.2.6　运行时常量池
运行时常量池（Runtime Constant Pool）是方法区的一部分。    
Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池（Constant Pool Table），用于
存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池中存放。\

运行时常量池相对于Class文件常量池的另外一个重要特征是具备动态性，Java语言并不要求常量一定只有编译期才能产生，也就是并非预置入Class文件中常量池的内容才能进入方
法区运行时常量池，运行期间也可能将新的常量放入池中，这种特性被开发人员利用得比较多的便是String类的intern（）方法。
#### 2.2.7　直接内存
直接内存（Direct Memory）==并不是虚拟机运行时数据区的一部分==，也不是Java虚拟机规范中定义的内存区域。但是这部分内存也被频繁地使用，而且也可能导致OutOfMemoryError异常出现
### 2.3　HotSpot虚拟机对象探秘
以常用的虚拟机HotSpot和常用的内存区域Java堆为例，深入探讨HotSpot虚拟机在Java堆中对象分配、布局和访问的全过程。

#### 2.3.1　对象的创建 p67
虚拟机遇到一条new指令时，首先将去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已被加载、解析和初始化过。如果没有，那必须先执行相应的类加载过程

在类加载检查通过后，接下来虚拟机将为新生对象分配内存。对象所需内存的大小在类加载完成后便可完全确定

为对象分配空间的任务等同于把一块确定大小的内存从Java堆中划分出来。

假设Java堆中内存是绝对规整的，所有用过的内
存都放在一边，空闲的内存放在另一边，中间放着一个指针作为分界点的指示器，那所分配
内存就仅仅是把那个指针向空闲空间那边挪动一段与对象大小相等的距离，这种分配方式称
为“==指针碰撞==”（Bump the Pointer）。

如果Java堆中的内存并不是规整的，已使用的内存和空
闲的内存相互交错，那就没有办法简单地进行指针碰撞了，虚拟机就必须维护一个列表，记
录上哪些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例，
并更新列表上的记录，这种分配方式称为“==空闲列表==”（Free List）。

==选择哪种分配方式由
Java堆是否规整决定，而Java堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决
定==。因此，在使用Serial、ParNew等带Compact过程的收集器时，系统采用的分配算法是指针
碰撞，而使用CMS这种基于Mark-Sweep算法的收集器时，通常采用空闲列表。

除如何划分可用空间之外，还有另外一个需要考虑的问题是对象创建在虚拟机中是非常
频繁的行为，即使是仅仅修改一个指针所指向的位置，在并发情况下也并不是线程安全的，
可能出现正在给对象A分配内存，指针还没来得及修改，对象B又同时使用了原来的指针来
分配内存的情况。

解决这个问题有两种方案，一种是对分配内存空间的动作进行同步处理
——实际上虚拟机采用CAS配上失败重试的方式保证更新操作的原子性；另一种是把内存分
配的动作按照线程划分在不同的空间之中进行，即每个线程在Java堆中预先分配一小块内
存，称为本地线程分配缓冲（Thread Local Allocation Buffer,TLAB）。

内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头），
如果使用TLAB，这一工作过程也可以提前至TLAB分配时进行。这一步操作保证了对象的实
例字段在Java代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。
#### 2.3.2　对象的内存布局
在HotSpot虚拟机中，对象在内存中存储的布局可以分为3块区域：对象头（Header）、实例数据（Instance Data）和对齐填充（Padding）

HotSpot虚拟机的对象头包括两部分信息，
- 第一部分用于存储对象自身的运行时数据，
如哈希码（HashCode）、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等
- 对象头的另外一部分是类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。

接下来的实例数据部分是对象真正存储的有效信息，也是在程序代码中所定义的各种类型的字段内容。无论是从父类继承下来的，还是在子类中定义的，都需要记录起来

#### 2.3.3　对象的访问定位
建立对象是为了使用对象，我们的Java程序需要通过栈上的reference数据来操作堆上的具体对象       
目前主流的访问方式有使用句柄和直接指针两种。

这两种对象访问方式各有优势，
- 使用句柄来访问的最大好处就是reference中存储的是稳
定的句柄地址，在对象被移动（垃圾收集时移动对象是非常普遍的行为）时只会改变句柄中的实例数据指针，而reference本身不需要修改。
- 使用直接指针访问方式的最大好处就是速度更快，它节省了一次指针定位的时间开销，
由于对象的访问在Java中非常频繁，因此这类开销积少成多后也是一项非常可观的执行成本。        
本书讨论的主要虚拟机Sun HotSpot而言，它是使用第二种方式进行对象访问的，但从
整个软件开发的范围来看，各种语言和框架使用句柄来访问的情况也十分常见。
### 2.4　实战：OutOfMemoryError异常

#### 2.4.1　Java堆溢出
Java堆用于存储对象实例，只要不断地创建对象，并且保证GC Roots到对象之间有可达路径来避免垃圾回收机制清除这些对象，那么在对象数量到达最大堆的容量限制后就会产生
内存溢出异常。

Java堆内存的OOM异常是实际应用中常见的内存溢出异常情况。当出现Java堆内存溢出
时，异常堆栈信息“java.lang.OutOfMemoryError”会跟着进一步提示“Java heap space”。

要解决这个区域的异常，一般的手段是先通过==内存映像分析工具（如Eclipse Memory
Analyzer）对Dump出来的堆转储快照进行分析==，重点是确认内存中的对象是否是必要的，也
就是要先分清楚到底是出现了内存泄漏（Memory Leak）还是内存溢出（Memory Overflow）。

如果是内存泄露，可进一步通过工具查看泄露对象到GC Roots的引用链。于是就能找到泄露对象是通过怎样的路径与GC Roots相关联并导致垃圾收集器无法自动回收它们的。掌握
了泄露对象的类型信息及GC Roots引用链的信息，就可以比较准确地定位出泄露代码的位
置。

如果不存在泄露，换句话说，就是内存中的对象确实都还必须存活着，那就应当检查虚
拟机的堆参数（-Xmx与-Xms），与机器物理内存对比看是否还可以调大，从代码上检查是
否存在某些对象生命周期过长、持有状态时间过长的情况，尝试减少程序运行期的内存消耗。
#### 2.4.2　虚拟机栈和本地方法栈溢出
在HotSpot虚拟机中并不区分虚拟机栈和本地方法栈，==对于HotSpot来说==，虽
然-Xoss参数（设置本地方法栈大小）存在，但实际上是无效的，==栈容量只由-Xss参数设定==

在Java虚拟机规范中描述了两种异常：
- 如果线程请求的栈深度大于虚拟机所允许的最大深度，将抛出StackOverflowError异常。
- 如果虚拟机在扩展栈时无法申请到足够的内存空间，则抛出OutOfMemoryError异常。

在单个线程下，无论是由于栈帧太大还是虚拟机栈容量太小，当内存无
法分配的时候，虚拟机抛出的都是StackOverflowError异常。

操作系统分配给每个进程的内存是有限制的，譬如32位的Windows
限制为2GB

虚拟机提供了参数来控制Java堆和方法区的这两部分内存的最大值。

剩余的内
存为2GB（操作系统限制）减去Xmx（最大堆容量），再减去MaxPermSize（最大方法区容
量），程序计数器消耗内存很小，可以忽略掉。如果虚拟机进程本身耗费的内存不计算在
内，剩下的内存就由虚拟机栈和本地方法栈“瓜分”了
> 2GB - Xmx - MaxPermSize = 虚拟机栈

开发多线程的应用时，如果使用虚拟机默认参数，栈深度在大多数情况下，达到1000～2000完全没有问题

==如果是建立过多线程导致的内存溢出==，在不能减少线程数或者更换64位虚拟机的情况下，就只能通过减少最大堆和减少栈容量来换取更多的线程
#### 2.4.3　方法区和运行时常量池溢出 p78
String.intern（）是一个Native方法，它的作用是：    
如果字符串常量池中已经包含一个等
于此String对象的字符串，则返回代表池中这个字符串的String对象；  
否则，将此String对象包
含的字符串添加到常量池中，并且返回此String对象的引用

在JDK 1.6及之前的版本中，由
于常量池分配在永久代内，我们可以通过-XX：PermSize和-XX：MaxPermSize限制方法区大小，从而间接限制其中常量池的容量，

==方法区用于存放Class的相关信息==，如类名、访问修饰符、常量池、字段描述、方法描述等。

方法区溢出也是一种常见的内存溢出异常，一个类要被垃圾收集器回收掉，判定条件是比较苛刻的。        

==在经常动态生成大量Class的应用中，需要特别注意类的回收状况==。这类场景除
了上面提到的程序使用了CGLib字节码增强和动态语言之外，常见的还有：大量JSP或动态产生JSP文件的应用（==JSP第一次运行时需要编译为Java类==）、基于OSGi的应用（即使是同一个
类文件，被不同的加载器加载也会视为不同的类）等。

#### 2.4.4　本机直接内存溢出
DirectMemory容量可通过-XX：MaxDirectMemorySize指定，如果不指定，则默认与Java堆最大值（-Xmx指定）一样

### 2.5　本章小结  p81
通过本章的学习，我们明白了==虚拟机中的内存是如何划分==的，==哪部分区域、什么样的代码和操作可能导致内存溢出异常==。虽然Java有垃圾收集机制，但内存溢出异常离我们仍然并
不遥远，本章只是讲解了==各个区域出现内存溢出异常的原因==，第3章将详细讲解Java垃圾收
集机制为了避免内存溢出异常的出现都做了哪些努力。

## 第3章　垃圾收集器与内存分配策略
Java与C++之间有一堵由内存动态分配和垃圾收集技术所围成的“高墙”，墙外面的人想
进去，墙里面的人却想出来。
### 3.1　概述
目前内存的动态分配与内存回收技术已经相当成熟，一切看起
来都进入了“自动化”时代，那为什么我们还要去了解GC和内存分配呢？

当需要==排查各种内存溢出、内存泄漏问题==时，==当垃圾收集成为系统达到更高并发量的瓶颈时==，我
们就需要对这些“自动化”的技术实施必要的监控和调节。
- 程序计数器、虚拟机栈、本地方法栈3个区域随线程而生，随线程而灭
- 栈中的栈帧随着方法的进入和退出而有条不紊地执行着出栈和入栈操作。每一个
栈帧中分配多少内存基本上是在类结构确定下来时就已知的
- ==而Java堆和方法区则不一
样==，一个接口中的多个实现类需要的内存可能不一样，一个方法中的多个分支需要的内存也可能不一样，  
我们只有在程序处于运行期间时才能知道会创建哪些对象，这部分内存的分配和回收都是动态的，垃圾收集器所关注的是这部分内存  
本章后续讨论中的“内存”分配与回
收也仅指这一部分内存。
### 3.2　对象已死吗
==在堆里面存放着Java世界中几乎所有的对象实例==，    
垃圾收集器在对堆进行回收前，第一件事情就是要确定这些对象之中哪些还“存活”着，哪些已经“死去”（即不可能再被任何途径使用的对象）。
#### 3.2.1　引用计数算法
很多教科书判断对象是否存活的算法是这样的：     
给对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加1；当引用失效时，计数器值就减1；   
任何时刻计数器为0的对象就是不可能再被使用的

主流的Java虚拟机里面==没有选用引用计数算法来管理内存==，其中最主要的原因是它很难解决对象之间相互循环引用的问题。
#### 3.2.2　可达性分析算法
在主流的商用程序语言（Java、C#，甚至包括前面提到的古老的Lisp）的主流实现中，都是称通过==可达性分析（Reachability Analysis==）来判定对象是否存活的

这个算法的基本思路就是==通过一系列的称为“GC Roots”的对象作为起始点==，从这些节点开始==向下搜索==，==搜索所走过的路径称为引用链==（Reference Chain），==当一个对象到GC Roots没有任何引用链相连==（用图论的话来说，就是从GCRoots到这个对象不可达）时，==则证明此对象是不可用的==。

在Java语言中，可作为GC Roots的对象包括下面几种：
- 虚拟机栈（栈帧中的本地变量表）中引用的对象。
- 方法区中类静态属性引用的对象。
- 方法区中常量引用的对象。
- 本地方法栈中JNI（即一般说的Native方法）引用的对象。
#### 3.2.3　再谈引用
在JDK 1.2之后，Java对引用的概念进行了扩充，将引用分为
- 强引用（Strong
Reference）、
- 软引用（Soft Reference）、
- 弱引用（Weak Reference）、
- 虚引用（Phantom
Reference）

这4种引用强度依次逐渐减弱。
- 强引用就是指在程序代码之中普遍存在的，类似“Object obj=new Object（）”这类的引
用，只要强引用还存在，垃圾收集器永远不会回收掉被引用的对象。
- 软引用是用来描述一些还有用但并非必需的对象。对于软引用关联着的对象，在系统将
要发生内存溢出异常之前，将会把这些对象列进回收范围之中进行第二次回收。如果这次回
收还没有足够的内存，才会抛出内存溢出异常。在JDK 1.2之后，提供了SoftReference类来实
现软引用。
- 弱引用也是用来描述非必需对象的，但是它的强度比软引用更弱一些，被弱引用关联的
对象只能生存到下一次垃圾收集发生之前。当垃圾收集器工作时，无论当前内存是否足够，
都会回收掉只被弱引用关联的对象。在JDK 1.2之后，提供了WeakReference类来实现弱引
用。
- 虚引用也称为幽灵引用或者幻影引用，它是最弱的一种引用关系。一个对象是否有虚引
用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一
个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。在
JDK 1.2之后，提供了PhantomReference类来实现虚引用。
#### 3.2.4　生存还是死亡 p87
即使在可达性分析算法中不可达的对象，也并非是“非死不可”的，这时候它们暂时处于“缓刑”阶段，要真正宣告一个对象死亡，至少要==经历两次标记过程==
- 如果对象在进行可达
性分析后发现没有与GC Roots相连接的引用链，那它将会被==第一次标记并且进行一次筛选==，
筛选的条件是此对象是否有必要执行finalize（）方法。当对象没有覆盖finalize（）方法，或
者finalize（）方法已经被虚拟机调用过，虚拟机将这两种情况都视为“没有必要执行”。
- 如果这个对象被判定为有必要执行finalize（）方法，那么这个对象将会放置在一个叫做
F-Queue的队列之中，并在稍后由一个由虚拟机自动建立的、低优先级的Finalizer线程去执行它。     
如果对象要在finalize（）中成功拯救自己——只要重新与引用链
上的任何一个对象建立关联即可，譬如把自己（this关键字）赋值给某个类变量或者对象的
成员变量，那在第二次标记时它将被移除出“即将回收”的集合；如果对象这时候还没有逃
脱，那基本上它就真的被回收了

finalize（）能做的所有工作，使用try-finally或者其他方式都可以做得更好、更及时，所以笔
者建议大家完全可以忘掉Java语言中有这个方法的存在。
#### 3.2.5　回收方法区 p89

### 3.3　垃圾收集算法
由于垃圾收集算法的实现涉及大量的程序细节，而且各个平台的虚拟机操作内存的方法又各不相同，因此本节不打算过多地讨论算法的实现，只是介绍几种算法的思想及其发展过程。
#### 3.3.1　标记-清除算法

#### 3.3.2　复制算法  p91
现在的商业虚拟机都采用这种收集算法来回收新生代

#### 3.3.3　标记-整理算法

#### 3.3.4　分代收集算法
当前商业虚拟机的垃圾收集都采用“分代收集”（Generational Collection）算法，  
这种算法并没有什么新的思想，只是根据对象存活周期的不同将内存划分为几块  
一般是把Java堆
分为新生代和老年代，    
这样就可以根据各个年代的特点采用最适当的收集算法。  
- ==在新生代中==，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就==选用复制算法==，只需要付出少量存活对象的复制成本就可以完成收集。
- 而==老年代==中因为对象存活率高、没有额外空间对它进行分配担保，就必须==使用“标记—清理”或者“标记—整理”算法==来进行回收。
 ### 3.4　HotSpot的算法实现
#### 3.4.1　枚举根节点


#### 3.5.8　理解GC日志  p112


### 3.6　内存分配与回收策略 p115


### 3.7　本章小结 p122
本章介绍了垃圾收集的算法、几款JDK 1.7中提供的垃圾收集器特点以及运作原理。        
通过代码实例验证了Java虚拟机中自动内存分配及回收的主要规则。

内存回收与垃圾收集器在很多时候都是影响系统性能、并发能力的主要因素之一，    
虚拟机之所以提供多种不同的收集器以及提供大量的调节参数，是因为只有根据实际应用需求、实现方式选择最优的收集方式才能获取最高的性能    
==如果要到实践调优阶段==，那么必须了解每个具体收集器的行为、优势和劣势、调节参数。      
在接下来的两章中，作者将会介绍内存分析的工具和调优的一些具体案例。

## 第四章 虚拟机性能监控与故障处理工具
### 4.2 JDK的命令行工具 p126
#### 4.2.1　jps：虚拟机进程状况工具

#### 4.2.2　jstat：虚拟机统计信息监视工具

#### 4.2.3　jinfo：Java配置信息工具

#### 4.2.4　jmap：Java内存映像工具

#### 4.2.5　jhat：虚拟机堆转储快照分析工具

#### 4.2.6　jstack：Java堆栈跟踪工具

#### 4.2.7　HSDIS：JIT生成代码反汇编

### 4.3　JDK的可视化工具 p139

#### 4.3.1　JConsole：Java监视与管理控制台

### 4.4 本章小结 p157
本章介绍了随 JDK发布的6个命令行工具和两个可视化的故障处理工具

## 第五章 调优案例分析与实战 p159

- 5.2.1　高性能硬件上的程序部署策略
- 5.2.2　集群间同步导致的内存溢出
- 5.2.3　堆外内存导致的溢出错误
- 5.2.4　外部命令导致系统缓慢
- 5.2.5　服务器JVM进程崩溃
- 5.2.6　不恰当数据结构导致内存占用过大
- 5.2.7　由Windows虚拟内存导致的长时间停顿

### 5.3　实战：Eclipse运行速度调优 p170

### 5.4 本章小结 p189
Java虚拟机的内存管理与 垃圾收集 是虚拟机 结构体系中最重要的组成部分