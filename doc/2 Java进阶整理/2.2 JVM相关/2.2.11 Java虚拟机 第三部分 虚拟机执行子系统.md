## 第6章　类文件结构 p192
代码编译的结果是从本地机器码转变为字节码

随着时间的推移，谁能保证日后Java虚拟机在语
言无关性上的优势不会赶上甚至超越它在平台无关性上的优势呢？

实现语言无关性的基础仍然是虚拟机和字节码存储格式。Java虚拟机不和包括Java在内
的任何语言绑定，它只与“Class文件”这种特定的二进制文件格式所关联

使用Java编译
器可以把Java代码编译为存储字节码的Class文件，使用JRuby等其他语言的编译器一样可以
把程序代码编译成Class文件，虚拟机并不关心Class的来源是何种语言

任何一个Class文件都对应着唯一一个类或接口的定义信息，但反过来说，类或接
口并不一定都得定义在文件里（譬如类或接口也可以通过类加载器直接生成
### 6.3 Class类文件的结构
Class文件是一组以8位字节为基础单位的二进制流

根据Java虚拟机规范的规定，Class文件格式采用一种类似于C语言结构体的伪结构来存
储数据，这种伪结构中只有两种数据类型：无符号数和表
> 无符号数      

无符号数属于基本的数据类型，以u1、u2、u4、u8来分别代表1个字节、2个字节、4个
字节和8个字节的无符号数，无符号数可以用来描述数字、索引引用、数量值或者按照UTF-8
编码构成字符串值。
> 表    

表是由多个无符号数或者其他表作为数据项构成的复合数据类型，所有表都习惯性地
以“_info”结尾。表用于描述有层次关系的复合结构的数据，==整个Class文件本质上就是一张表==

### 6.3.1 魔数与Class文件的版本 p196
每个Class文件的头4个字节称为魔数（Magic Number），它的唯一作用是确定这个文件是否为一个能被虚拟机接受的Class文件

紧接着魔数的4个字节存储的是Class文件的版本号，  
高版本的JDK能向下兼容以前版本的Class文件，但不能运行以后版本的Class文件，即使文件格式并未发生任何变化，虚拟机也必须拒绝执行超过其版本号的Class文件。
### 6.3.2　常量池
由于常量池中常量的数量是不固定的，所以在常量池的入口需要放置一项u2类型的数据，代表常量池容量计数值      

常量池中主要存放两大类常量：字面量（Literal）和符号引用（Symbolic References）。  
- 字面量比较接近于Java语言层面的常量概念，如文本字符串、声明为final的常量值等。  
- 符号引用则属于编译原理方面的概念，包括了下面三类常量：
    - 类和接口的全限定名（Fully Qualified Name）
    - 字段的名称和描述符（Descriptor）
    - 方法的名称和描述符

当虚拟机运行时，需要从常量池获得对应的符号引用，再在类创建时或运行时解析、翻译到具体的内存地址之中

在JDK的bin目录中，Oracle公司已经为我们准备好一个专门用于分析Class文件字节码的工具：javap 
```
javap -verbose 类名
```
> 常量池中14种常用项的结构 p202
### 6.3.3　访问标志 p204

在常量池结束之后，紧接着的两个字节代表访问标志（access_flags）    
这个标志用于识
别一些类或者接口层次的访问信息，包括：这个Class是类还是接口；   
是否定义为public类型；是否定义为abstract类型；如果是类的话，是否被声明为final等

### 6.3.4　类索引、父类索引与接口索引集合
类索引（this_class）和父类索引（super_class）都是一个u2类型的数据， 
而接口索引集合（interfaces）是一组u2类型的数据的集合    

类索引、父类索引和接口索引集合都按顺序排列在访问标志之后，  
类索引和父类索引用
两个u2类型的索引值表示，它们各自指向一个类型为CONSTANT_Class_info的类描述符常
量，通过CONSTANT_Class_info类型的常量中的索引值可以找到定义在
CONSTANT_Utf8_info类型的常量中的全限定名字符串。    
图6-6演示了代码清单6-1的代码的类
索引查找过程。

### 6.3.5　字段表集合 

### 6.3.6　方法表集合
方法表的结构如同字段表一样，依次包括了
- 访问标志（access_flags）、
- 名称索引（name_index）、
- 描述符索引（descriptor_index）、
- 属性表集合（attributes）

### 6.3.7　属性表集合
有时间再慢慢过一遍

## 6.4　字节码指令简介 p226

## 6.5　公有设计和私有实现 p240

## 6.6　Class文件结构的发展 p241

## 6.7 本章小结 p242
Class文件是Java虚拟机执行引擎的数据入口，也是Java技术体系的基础构成之一

本章详细讲解了Class文件结构中的各个组成部分，以及每个部分的定义、数据结构和使用方法

## 第7章　虚拟机类加载机制
## 7.1 概述
虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这就是虚拟机的类加载机制。

在Java语言里面，类型的加载、连接和初始化过程都是在程序运行期间完成的（==多态，spring的依赖注入，分布式系统的消息传递==）

## 7.2　类加载的时机
类从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期包括-
- 加载（Loading）、
- 验证（Verification）、
- 准备（Preparation）、
- 解析（Resolution）、
- 初始化（Initialization）、
- 使用（Using）
- 卸载（Unloading）7个阶段。  
其中验证、准备、解析3个
部分统称为连接（Linking），

加载、验证、准备、初始化和卸载这5个阶段的顺序是确定的，类的加载过程
必须按照这种顺序按部就班地开始，    
而解析阶段则不一定：它在某些情况下可以在初始化阶段之后再开始，这是为了支持Java语言的运行时绑定（也称为动态绑定或晚期绑定）

> 什么情况下需要开始类加载过程的第一个阶段：加载

- 遇到new、getstatic、putstatic或invokestatic这4条字节码指令时，如果类没有进行过初
始化，则需要先触发其初始化。生成这4条指令的最常见的Java代码场景是
    - 使用new关键字实例化对象的时候、
    - 读取或设置一个类的静态字段（被final修饰、已在编译期把结果放入常
量池的静态字段除外）的时候，
    - 调用一个类的静态方法的时候
- 使用java.lang.reflect包的方法对类进行反射调用的时候，如果类没有进行过初始化，则需要先触发其初始化
- 当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。
- 当虚拟机启动时，用户需要指定一个要执行的主类（包含main（）方法的那个类），虚拟机会先初始化这个主类。
- 当使用JDK 1.7的动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后
的解析结果REF_getStatic、REF_putStatic、REF_invokeStatic的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则需要先触发其初始化。

## 7.3　类加载的过程
### 7.3.1　加载
在加载阶段，虚拟机需要完成以下3件事情：
1. ==通过一个类的全限定名来获取定义此类的二进制字节流==。
    - 从ZIP包中读取，这很常见，最终成为日后JAR、EAR、WAR格式的基础。
    - 从网络中获取，这种场景最典型的应用就是Applet。
    - 运行时计算生成，这种场景使用得最多的就是动态代理技术，在java.lang.reflect.Proxy
中，就是用了ProxyGenerator.generateProxyClass来为特定接口生成形式为“*$Proxy”的代理类
的二进制字节流。
2. 将这个字节流所代表的静态存储结构==转化为方法区的运行时数据结构==。
3. 在内存中==生成一个代表这个类的java.lang.Class对象==，==作为方法区这个类的各种数据的访问入口==。

### 7.3.2　验证
验证是连接阶段的第一步，这一阶段的目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。  

用纯粹的Java代码无法做到诸如访问数组边界以外的数据、将一个对象转型为它并未实现的类型、跳转到不存在
的代码行之类的事情，    
如果这样做了，编译器将拒绝编译。    
但前面已经说过，Class文件并不
一定要求用Java源码编译而来，可以使用任何途径产生，甚至包括用十六进制编辑器直接编写来产生Class文件。    
在字节码语言层面上，上述Java代码无法做到的事情都是可以实现的

从执行性能的角度上讲，验证阶段的工作量在虚拟机的类加载子系统中又占了相当大的一部分

验证阶段大致上会完成下面4个阶段的检验动作：文件格式验证、元数据验证、字节码验证、符号引用验证。

#### 1.文件格式验证
第一阶段要验证字节流是否符合Class文件格式的规范，并且能被当前版本的虚拟机处理。

这阶段的验证是基于二进制字节流进行
的，只有通过了这个阶段的验证后，字节流才会进入内存的方法区中进行存储，  
所以后面的3个验证阶段全部是基于方法区的存储结构进行的，不会再直接操作字节流。

#### 2.元数据验证 p250
对字节码描述的信息进行语义分析，以保证其描述的信息符合Java语言规范的要求    

#### 3.字节码验证
通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的,对类的方法体进行校验分析，保证被校验类的方法在运行时不会做出危害虚拟机安全的事件

#### 4.符号引用验证
符号引用中通过字符串描述的全限定名是否能找到对应的类。    
在指定类中是否存在符合方法的字段描述符以及简单名称所描述的方法和字段。  
符号引用中的类、字段、方法的访问性（private、protected、public、default）是否可被
当前类访问。
### 7.3.3　准备 p252
这个阶段，对象还没有实例化，系统为类的属性进行默认初始化赋值，如果final修饰，则赋值为指定值

### 7.3.4 解析
虚拟机将常量池内的 符号引用替换为直接引用，

符号引用（Symbolic References）：  
符号引用以一组符号来描述所引用的目标，符号可
以是任何形式的字面量，只要使用时能无歧义地定位到目标即可

直接引用（Direct References）：  
直接引用可以是直接指向目标的指针、相对偏移量或是
一个能间接定位到目标的句柄。直接引用是和虚拟机实现的内存布局相关的，同一个符号引用在不同虚拟机实例上翻译出来的直接引用一般不会相同  

1. 类或接口的解析       
假设当前代码位于类D中，把一个从未解析过的符号引用N解析为一个类或接口C的直接引用，虚拟机需要三个步骤完成解析
    - 如果C不是数组，虚拟机会把N的全限定名传给D的类加载器去加载C这个类
    - 
    - 
2. 字段解析
3. 类方法解析
4. 接口方法解析

### 7.3.5 初始化
类初始化是类加载过程的最后一步，前面的类加载过程中，除了加载阶段用户的程序可以通过自定义类加载器参与，其他动作完全由虚拟机主导和控制；      
到了初始化阶段，在开始执行Java代码生成的字节码  

初始化阶段是执行类构造器＜clinit＞（）方法的过程。  

## 7.4 类加载器 p259
通过一个类的全限定名来获取描述此类的二进制字节流        

应用程序可以自己决定如何获取所需要的类  

### 7.4.1 类与类加载器
怎么确立一个类在Java虚拟机中的唯一性：来源于同一个class文件，被同一个类加载器加载      
相等判断：  
- equals()
- isAssignableFrom（）
- isInstance（）

每一个类加载器，都拥有一个独立的类名称空间，==不同的加载器加载同一个类时，产生的实例其实是不同的==

### 7.4.2 双亲委派模型 p262
三种类加载器    
- 启动类加载器（Bootstrap ClassLoader）  
这个类将器负责将存放在＜
JAVA_HOME＞\lib目录中的，或者被-Xbootclasspath参数所指定的路径中的，并且是虚拟机
识别的（仅按照文件名识别，如rt.jar，名字不符合的类库即使放在lib目录中也不会被加载）类库加载到虚拟机内存中。
- 扩展类加载器（Extension ClassLoader） 
这个加载器由sun.misc.Launcher
$ExtClassLoader实现，它负责加载＜JAVA_HOME＞\lib\ext目录中的，或者被java.ext.dirs系
统变量所指定的路径中的所有类库，开发者可以直接使用扩展类加载器。
- 应用程序类加载器（Application ClassLoader）   
这个类加载器由sun.misc.Launcher $App-
ClassLoader实现。由于这个类加载器是ClassLoader中的getSystemClassLoader（）方法的返回
值，所以一般也称它为系统类加载器。  
它负责加载用户类路径（ClassPath）上所指定的类
库，开发者可以直接使用这个类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。      

==双亲委派模型的工作过程==是：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，  
因此所有的加载请求最终都应该传送到顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去加载。

使用双亲委派模型来组织类加载器之间的关系，有一个显而易见的好处就是==Java类随着它的类加载器一起具备了一种带有优先级的层次关系==

实现双亲委派的代码都集中在java.lang.ClassLoader的loadClass（）方法之中

先检查是否已经被加载过，若没有加载则调用父加载器的loadClass（）方法，若父加载器为空则默认使用系统类加载器作为父加载器。    
如果父类加载失败，抛出ClassNotFoundException异常后，再调用自己的findClass（）方法进行加载。

### 7.4.3　破坏双亲委派模型  重点
JDK 1.2之后已不提倡用户再去覆盖loadClass（）方法，而应当把自己的类加载逻辑写到findClass（）方法中， 
在loadClass（）方法的逻辑里如果父类加载失败，则会调用自己的findClass（）方法来完成加载，这样就可以保证新写出来的类加载器是符合双亲委派规则的。

## 7.5 本章小结
介绍了类加载过程的“加载”、“验证”、“准备”、“解析”和“初始化”5个阶段中虚拟机进行了哪些动作，  
还介绍了类加载器的工作原理及其对虚拟机的意义。

回答了
- 如何在Class文件中定义类，
- 如何将类加载到虚拟机中    
这两个问题

## 第8章　虚拟机字节码执行引擎  p267

## 第9章　类加载及执行子系统的案例与实战 p305

## 9.4 本章小结 p325

